# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'HeartbeatCheckMonitoredResourceArgs',
    'HeartbeatCheckMonitoredResourceArgsDict',
    'PagespeedCheckAlertConfigArgs',
    'PagespeedCheckAlertConfigArgsDict',
    'PagespeedCheckMonitoredResourceArgs',
    'PagespeedCheckMonitoredResourceArgsDict',
    'SslCheckAlertConfigArgs',
    'SslCheckAlertConfigArgsDict',
    'SslCheckMonitoredResourceArgs',
    'SslCheckMonitoredResourceArgsDict',
    'UptimeCheckDnsCheckArgs',
    'UptimeCheckDnsCheckArgsDict',
    'UptimeCheckHttpCheckArgs',
    'UptimeCheckHttpCheckArgsDict',
    'UptimeCheckHttpCheckBasicAuthenticationArgs',
    'UptimeCheckHttpCheckBasicAuthenticationArgsDict',
    'UptimeCheckHttpCheckContentMatchersArgs',
    'UptimeCheckHttpCheckContentMatchersArgsDict',
    'UptimeCheckIcmpCheckArgs',
    'UptimeCheckIcmpCheckArgsDict',
    'UptimeCheckLocationArgs',
    'UptimeCheckLocationArgsDict',
    'UptimeCheckMonitoredResourceArgs',
    'UptimeCheckMonitoredResourceArgsDict',
    'UptimeCheckTcpCheckArgs',
    'UptimeCheckTcpCheckArgsDict',
    'UptimeCheckTcpCheckAuthenticationArgs',
    'UptimeCheckTcpCheckAuthenticationArgsDict',
]

MYPY = False

if not MYPY:
    class HeartbeatCheckMonitoredResourceArgsDict(TypedDict):
        host: NotRequired[pulumi.Input[str]]
        """
        Name of the hosting provider
        """
elif False:
    HeartbeatCheckMonitoredResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HeartbeatCheckMonitoredResourceArgs:
    def __init__(__self__, *,
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host: Name of the hosting provider
        """
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the hosting provider
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class PagespeedCheckAlertConfigArgsDict(TypedDict):
        alert_bigger: NotRequired[pulumi.Input[int]]
        """
        An alert will be sent if the size of the page is larger than this value (kb).
        """
        alert_slower: NotRequired[pulumi.Input[int]]
        """
        An alert will be sent if the load time of the page exceeds this value (ms).
        """
        alert_smaller: NotRequired[pulumi.Input[int]]
        """
        An alert will be sent if the size of the page is smaller than this value (kb).
        """
elif False:
    PagespeedCheckAlertConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagespeedCheckAlertConfigArgs:
    def __init__(__self__, *,
                 alert_bigger: Optional[pulumi.Input[int]] = None,
                 alert_slower: Optional[pulumi.Input[int]] = None,
                 alert_smaller: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] alert_bigger: An alert will be sent if the size of the page is larger than this value (kb).
        :param pulumi.Input[int] alert_slower: An alert will be sent if the load time of the page exceeds this value (ms).
        :param pulumi.Input[int] alert_smaller: An alert will be sent if the size of the page is smaller than this value (kb).
        """
        if alert_bigger is not None:
            pulumi.set(__self__, "alert_bigger", alert_bigger)
        if alert_slower is not None:
            pulumi.set(__self__, "alert_slower", alert_slower)
        if alert_smaller is not None:
            pulumi.set(__self__, "alert_smaller", alert_smaller)

    @property
    @pulumi.getter(name="alertBigger")
    def alert_bigger(self) -> Optional[pulumi.Input[int]]:
        """
        An alert will be sent if the size of the page is larger than this value (kb).
        """
        return pulumi.get(self, "alert_bigger")

    @alert_bigger.setter
    def alert_bigger(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "alert_bigger", value)

    @property
    @pulumi.getter(name="alertSlower")
    def alert_slower(self) -> Optional[pulumi.Input[int]]:
        """
        An alert will be sent if the load time of the page exceeds this value (ms).
        """
        return pulumi.get(self, "alert_slower")

    @alert_slower.setter
    def alert_slower(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "alert_slower", value)

    @property
    @pulumi.getter(name="alertSmaller")
    def alert_smaller(self) -> Optional[pulumi.Input[int]]:
        """
        An alert will be sent if the size of the page is smaller than this value (kb).
        """
        return pulumi.get(self, "alert_smaller")

    @alert_smaller.setter
    def alert_smaller(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "alert_smaller", value)


if not MYPY:
    class PagespeedCheckMonitoredResourceArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        URL or IP address of the website under test
        """
elif False:
    PagespeedCheckMonitoredResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PagespeedCheckMonitoredResourceArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str]):
        """
        :param pulumi.Input[str] address: URL or IP address of the website under test
        """
        pulumi.set(__self__, "address", address)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        URL or IP address of the website under test
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)


if not MYPY:
    class SslCheckAlertConfigArgsDict(TypedDict):
        alert_ats: pulumi.Input[Sequence[pulumi.Input[int]]]
        """
        List representing when alerts should be sent (days). Must be exactly 3 numerical values
        """
        on_broken: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable alerts when SSL certificate issues are found
        """
        on_expiry: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable alerts when the SSL certificate is to expire
        """
        on_mixed: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable alerts when mixed content is found
        """
        on_reminder: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable alert reminders
        """
elif False:
    SslCheckAlertConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SslCheckAlertConfigArgs:
    def __init__(__self__, *,
                 alert_ats: pulumi.Input[Sequence[pulumi.Input[int]]],
                 on_broken: Optional[pulumi.Input[bool]] = None,
                 on_expiry: Optional[pulumi.Input[bool]] = None,
                 on_mixed: Optional[pulumi.Input[bool]] = None,
                 on_reminder: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] alert_ats: List representing when alerts should be sent (days). Must be exactly 3 numerical values
        :param pulumi.Input[bool] on_broken: Whether to enable alerts when SSL certificate issues are found
        :param pulumi.Input[bool] on_expiry: Whether to enable alerts when the SSL certificate is to expire
        :param pulumi.Input[bool] on_mixed: Whether to enable alerts when mixed content is found
        :param pulumi.Input[bool] on_reminder: Whether to enable alert reminders
        """
        pulumi.set(__self__, "alert_ats", alert_ats)
        if on_broken is not None:
            pulumi.set(__self__, "on_broken", on_broken)
        if on_expiry is not None:
            pulumi.set(__self__, "on_expiry", on_expiry)
        if on_mixed is not None:
            pulumi.set(__self__, "on_mixed", on_mixed)
        if on_reminder is not None:
            pulumi.set(__self__, "on_reminder", on_reminder)

    @property
    @pulumi.getter(name="alertAts")
    def alert_ats(self) -> pulumi.Input[Sequence[pulumi.Input[int]]]:
        """
        List representing when alerts should be sent (days). Must be exactly 3 numerical values
        """
        return pulumi.get(self, "alert_ats")

    @alert_ats.setter
    def alert_ats(self, value: pulumi.Input[Sequence[pulumi.Input[int]]]):
        pulumi.set(self, "alert_ats", value)

    @property
    @pulumi.getter(name="onBroken")
    def on_broken(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable alerts when SSL certificate issues are found
        """
        return pulumi.get(self, "on_broken")

    @on_broken.setter
    def on_broken(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_broken", value)

    @property
    @pulumi.getter(name="onExpiry")
    def on_expiry(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable alerts when the SSL certificate is to expire
        """
        return pulumi.get(self, "on_expiry")

    @on_expiry.setter
    def on_expiry(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_expiry", value)

    @property
    @pulumi.getter(name="onMixed")
    def on_mixed(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable alerts when mixed content is found
        """
        return pulumi.get(self, "on_mixed")

    @on_mixed.setter
    def on_mixed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_mixed", value)

    @property
    @pulumi.getter(name="onReminder")
    def on_reminder(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable alert reminders
        """
        return pulumi.get(self, "on_reminder")

    @on_reminder.setter
    def on_reminder(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "on_reminder", value)


if not MYPY:
    class SslCheckMonitoredResourceArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        URL of the server under test
        """
        hostname: NotRequired[pulumi.Input[str]]
        """
        Hostname of the server under test
        """
elif False:
    SslCheckMonitoredResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SslCheckMonitoredResourceArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: URL of the server under test
        :param pulumi.Input[str] hostname: Hostname of the server under test
        """
        pulumi.set(__self__, "address", address)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        URL of the server under test
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the server under test
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


if not MYPY:
    class UptimeCheckDnsCheckArgsDict(TypedDict):
        dns_ips: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of IP addresses to compare against returned DNS records
        """
        dns_server: NotRequired[pulumi.Input[str]]
        """
        FQDN or IP address of the nameserver to query
        """
elif False:
    UptimeCheckDnsCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckDnsCheckArgs:
    def __init__(__self__, *,
                 dns_ips: pulumi.Input[Sequence[pulumi.Input[str]]],
                 dns_server: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_ips: List of IP addresses to compare against returned DNS records
        :param pulumi.Input[str] dns_server: FQDN or IP address of the nameserver to query
        """
        pulumi.set(__self__, "dns_ips", dns_ips)
        if dns_server is not None:
            pulumi.set(__self__, "dns_server", dns_server)

    @property
    @pulumi.getter(name="dnsIps")
    def dns_ips(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of IP addresses to compare against returned DNS records
        """
        return pulumi.get(self, "dns_ips")

    @dns_ips.setter
    def dns_ips(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "dns_ips", value)

    @property
    @pulumi.getter(name="dnsServer")
    def dns_server(self) -> Optional[pulumi.Input[str]]:
        """
        FQDN or IP address of the nameserver to query
        """
        return pulumi.get(self, "dns_server")

    @dns_server.setter
    def dns_server(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dns_server", value)


if not MYPY:
    class UptimeCheckHttpCheckArgsDict(TypedDict):
        basic_authentication: NotRequired[pulumi.Input['UptimeCheckHttpCheckBasicAuthenticationArgsDict']]
        """
        Basic Authentication (RFC7235) configuration block
        """
        content_matchers: NotRequired[pulumi.Input['UptimeCheckHttpCheckContentMatchersArgsDict']]
        """
        Content matcher configuration block. This is used to assert values within the response of the request
        """
        enable_cookies: NotRequired[pulumi.Input[bool]]
        """
        Whether to enable cookie storage
        """
        final_endpoint: NotRequired[pulumi.Input[str]]
        """
        Specify where the redirect chain should end
        """
        follow_redirects: NotRequired[pulumi.Input[bool]]
        """
        Whether to follow redirects when testing. Disabled by default
        """
        request_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Represents headers to be sent when making requests
        """
        request_method: NotRequired[pulumi.Input[str]]
        """
        Type of HTTP check. Either HTTP, or HEAD
        """
        request_payload: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Payload submitted with the request. Setting this updates the check to use the HTTP POST verb. Only one of `request_payload` or `request_payload_raw` may be specified
        """
        request_payload_raw: NotRequired[pulumi.Input[str]]
        """
        Raw payload submitted with the request. Setting this updates the check to use the HTTP POST verb. Only one of `request_payload` or `request_payload_raw` may be specified
        """
        status_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of status codes that trigger an alert. If not specified then the default status codes are used. Once set, the default status codes cannot be restored and ommitting this field does not clear the attribute
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait to receive the first byte
        """
        user_agent: NotRequired[pulumi.Input[str]]
        """
        Custom user agent string set when testing
        """
        validate_ssl: NotRequired[pulumi.Input[bool]]
        """
        Whether to send an alert if the SSL certificate is soon to expire
        """
elif False:
    UptimeCheckHttpCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckHttpCheckArgs:
    def __init__(__self__, *,
                 basic_authentication: Optional[pulumi.Input['UptimeCheckHttpCheckBasicAuthenticationArgs']] = None,
                 content_matchers: Optional[pulumi.Input['UptimeCheckHttpCheckContentMatchersArgs']] = None,
                 enable_cookies: Optional[pulumi.Input[bool]] = None,
                 final_endpoint: Optional[pulumi.Input[str]] = None,
                 follow_redirects: Optional[pulumi.Input[bool]] = None,
                 request_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 request_method: Optional[pulumi.Input[str]] = None,
                 request_payload: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 request_payload_raw: Optional[pulumi.Input[str]] = None,
                 status_codes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 timeout: Optional[pulumi.Input[int]] = None,
                 user_agent: Optional[pulumi.Input[str]] = None,
                 validate_ssl: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input['UptimeCheckHttpCheckBasicAuthenticationArgs'] basic_authentication: Basic Authentication (RFC7235) configuration block
        :param pulumi.Input['UptimeCheckHttpCheckContentMatchersArgs'] content_matchers: Content matcher configuration block. This is used to assert values within the response of the request
        :param pulumi.Input[bool] enable_cookies: Whether to enable cookie storage
        :param pulumi.Input[str] final_endpoint: Specify where the redirect chain should end
        :param pulumi.Input[bool] follow_redirects: Whether to follow redirects when testing. Disabled by default
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] request_headers: Represents headers to be sent when making requests
        :param pulumi.Input[str] request_method: Type of HTTP check. Either HTTP, or HEAD
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] request_payload: Payload submitted with the request. Setting this updates the check to use the HTTP POST verb. Only one of `request_payload` or `request_payload_raw` may be specified
        :param pulumi.Input[str] request_payload_raw: Raw payload submitted with the request. Setting this updates the check to use the HTTP POST verb. Only one of `request_payload` or `request_payload_raw` may be specified
        :param pulumi.Input[Sequence[pulumi.Input[str]]] status_codes: List of status codes that trigger an alert. If not specified then the default status codes are used. Once set, the default status codes cannot be restored and ommitting this field does not clear the attribute
        :param pulumi.Input[int] timeout: The number of seconds to wait to receive the first byte
        :param pulumi.Input[str] user_agent: Custom user agent string set when testing
        :param pulumi.Input[bool] validate_ssl: Whether to send an alert if the SSL certificate is soon to expire
        """
        if basic_authentication is not None:
            pulumi.set(__self__, "basic_authentication", basic_authentication)
        if content_matchers is not None:
            pulumi.set(__self__, "content_matchers", content_matchers)
        if enable_cookies is not None:
            pulumi.set(__self__, "enable_cookies", enable_cookies)
        if final_endpoint is not None:
            pulumi.set(__self__, "final_endpoint", final_endpoint)
        if follow_redirects is not None:
            pulumi.set(__self__, "follow_redirects", follow_redirects)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if request_method is not None:
            pulumi.set(__self__, "request_method", request_method)
        if request_payload is not None:
            pulumi.set(__self__, "request_payload", request_payload)
        if request_payload_raw is not None:
            pulumi.set(__self__, "request_payload_raw", request_payload_raw)
        if status_codes is not None:
            pulumi.set(__self__, "status_codes", status_codes)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)
        if user_agent is not None:
            pulumi.set(__self__, "user_agent", user_agent)
        if validate_ssl is not None:
            pulumi.set(__self__, "validate_ssl", validate_ssl)

    @property
    @pulumi.getter(name="basicAuthentication")
    def basic_authentication(self) -> Optional[pulumi.Input['UptimeCheckHttpCheckBasicAuthenticationArgs']]:
        """
        Basic Authentication (RFC7235) configuration block
        """
        return pulumi.get(self, "basic_authentication")

    @basic_authentication.setter
    def basic_authentication(self, value: Optional[pulumi.Input['UptimeCheckHttpCheckBasicAuthenticationArgs']]):
        pulumi.set(self, "basic_authentication", value)

    @property
    @pulumi.getter(name="contentMatchers")
    def content_matchers(self) -> Optional[pulumi.Input['UptimeCheckHttpCheckContentMatchersArgs']]:
        """
        Content matcher configuration block. This is used to assert values within the response of the request
        """
        return pulumi.get(self, "content_matchers")

    @content_matchers.setter
    def content_matchers(self, value: Optional[pulumi.Input['UptimeCheckHttpCheckContentMatchersArgs']]):
        pulumi.set(self, "content_matchers", value)

    @property
    @pulumi.getter(name="enableCookies")
    def enable_cookies(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable cookie storage
        """
        return pulumi.get(self, "enable_cookies")

    @enable_cookies.setter
    def enable_cookies(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_cookies", value)

    @property
    @pulumi.getter(name="finalEndpoint")
    def final_endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Specify where the redirect chain should end
        """
        return pulumi.get(self, "final_endpoint")

    @final_endpoint.setter
    def final_endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "final_endpoint", value)

    @property
    @pulumi.getter(name="followRedirects")
    def follow_redirects(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to follow redirects when testing. Disabled by default
        """
        return pulumi.get(self, "follow_redirects")

    @follow_redirects.setter
    def follow_redirects(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "follow_redirects", value)

    @property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Represents headers to be sent when making requests
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "request_headers", value)

    @property
    @pulumi.getter(name="requestMethod")
    def request_method(self) -> Optional[pulumi.Input[str]]:
        """
        Type of HTTP check. Either HTTP, or HEAD
        """
        return pulumi.get(self, "request_method")

    @request_method.setter
    def request_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_method", value)

    @property
    @pulumi.getter(name="requestPayload")
    def request_payload(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Payload submitted with the request. Setting this updates the check to use the HTTP POST verb. Only one of `request_payload` or `request_payload_raw` may be specified
        """
        return pulumi.get(self, "request_payload")

    @request_payload.setter
    def request_payload(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "request_payload", value)

    @property
    @pulumi.getter(name="requestPayloadRaw")
    def request_payload_raw(self) -> Optional[pulumi.Input[str]]:
        """
        Raw payload submitted with the request. Setting this updates the check to use the HTTP POST verb. Only one of `request_payload` or `request_payload_raw` may be specified
        """
        return pulumi.get(self, "request_payload_raw")

    @request_payload_raw.setter
    def request_payload_raw(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "request_payload_raw", value)

    @property
    @pulumi.getter(name="statusCodes")
    def status_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of status codes that trigger an alert. If not specified then the default status codes are used. Once set, the default status codes cannot be restored and ommitting this field does not clear the attribute
        """
        return pulumi.get(self, "status_codes")

    @status_codes.setter
    def status_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "status_codes", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait to receive the first byte
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)

    @property
    @pulumi.getter(name="userAgent")
    def user_agent(self) -> Optional[pulumi.Input[str]]:
        """
        Custom user agent string set when testing
        """
        return pulumi.get(self, "user_agent")

    @user_agent.setter
    def user_agent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_agent", value)

    @property
    @pulumi.getter(name="validateSsl")
    def validate_ssl(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to send an alert if the SSL certificate is soon to expire
        """
        return pulumi.get(self, "validate_ssl")

    @validate_ssl.setter
    def validate_ssl(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "validate_ssl", value)


if not MYPY:
    class UptimeCheckHttpCheckBasicAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    UptimeCheckHttpCheckBasicAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckHttpCheckBasicAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class UptimeCheckHttpCheckContentMatchersArgsDict(TypedDict):
        content: pulumi.Input[str]
        """
        String to look for within the response. Considered down if not found
        """
        include_headers: NotRequired[pulumi.Input[bool]]
        """
        Include header content in string match search
        """
        matcher: NotRequired[pulumi.Input[str]]
        """
        Whether to consider the check as down if the content is present within the response
        """
elif False:
    UptimeCheckHttpCheckContentMatchersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckHttpCheckContentMatchersArgs:
    def __init__(__self__, *,
                 content: pulumi.Input[str],
                 include_headers: Optional[pulumi.Input[bool]] = None,
                 matcher: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] content: String to look for within the response. Considered down if not found
        :param pulumi.Input[bool] include_headers: Include header content in string match search
        :param pulumi.Input[str] matcher: Whether to consider the check as down if the content is present within the response
        """
        pulumi.set(__self__, "content", content)
        if include_headers is not None:
            pulumi.set(__self__, "include_headers", include_headers)
        if matcher is not None:
            pulumi.set(__self__, "matcher", matcher)

    @property
    @pulumi.getter
    def content(self) -> pulumi.Input[str]:
        """
        String to look for within the response. Considered down if not found
        """
        return pulumi.get(self, "content")

    @content.setter
    def content(self, value: pulumi.Input[str]):
        pulumi.set(self, "content", value)

    @property
    @pulumi.getter(name="includeHeaders")
    def include_headers(self) -> Optional[pulumi.Input[bool]]:
        """
        Include header content in string match search
        """
        return pulumi.get(self, "include_headers")

    @include_headers.setter
    def include_headers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_headers", value)

    @property
    @pulumi.getter
    def matcher(self) -> Optional[pulumi.Input[str]]:
        """
        Whether to consider the check as down if the content is present within the response
        """
        return pulumi.get(self, "matcher")

    @matcher.setter
    def matcher(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "matcher", value)


if not MYPY:
    class UptimeCheckIcmpCheckArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Dummy attribute to allow for a nested block. This field should not be changed
        """
elif False:
    UptimeCheckIcmpCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckIcmpCheckArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Dummy attribute to allow for a nested block. This field should not be changed
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Dummy attribute to allow for a nested block. This field should not be changed
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class UptimeCheckLocationArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        Location description
        """
        ipv4: NotRequired[pulumi.Input[str]]
        """
        Location IPv4 address
        """
        ipv6: NotRequired[pulumi.Input[str]]
        """
        Location IPv6 address
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Location region
        """
        region_code: NotRequired[pulumi.Input[str]]
        """
        Location region code
        """
        status: NotRequired[pulumi.Input[str]]
        """
        Location status
        """
elif False:
    UptimeCheckLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckLocationArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 ipv4: Optional[pulumi.Input[str]] = None,
                 ipv6: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 region_code: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Location description
        :param pulumi.Input[str] ipv4: Location IPv4 address
        :param pulumi.Input[str] ipv6: Location IPv6 address
        :param pulumi.Input[str] region: Location region
        :param pulumi.Input[str] region_code: Location region code
        :param pulumi.Input[str] status: Location status
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if region_code is not None:
            pulumi.set(__self__, "region_code", region_code)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Location description
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[str]]:
        """
        Location IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv4", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[str]]:
        """
        Location IPv6 address
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Location region
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="regionCode")
    def region_code(self) -> Optional[pulumi.Input[str]]:
        """
        Location region code
        """
        return pulumi.get(self, "region_code")

    @region_code.setter
    def region_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region_code", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Location status
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class UptimeCheckMonitoredResourceArgsDict(TypedDict):
        address: pulumi.Input[str]
        """
        URL, FQDN, or IP address of the server under test
        """
        host: NotRequired[pulumi.Input[str]]
        """
        Name of the hosting provider
        """
elif False:
    UptimeCheckMonitoredResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckMonitoredResourceArgs:
    def __init__(__self__, *,
                 address: pulumi.Input[str],
                 host: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: URL, FQDN, or IP address of the server under test
        :param pulumi.Input[str] host: Name of the hosting provider
        """
        pulumi.set(__self__, "address", address)
        if host is not None:
            pulumi.set(__self__, "host", host)

    @property
    @pulumi.getter
    def address(self) -> pulumi.Input[str]:
        """
        URL, FQDN, or IP address of the server under test
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: pulumi.Input[str]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the hosting provider
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)


if not MYPY:
    class UptimeCheckTcpCheckArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        Destination port for TCP checks
        """
        authentication: NotRequired[pulumi.Input['UptimeCheckTcpCheckAuthenticationArgsDict']]
        """
        Authentication configuration block
        """
        protocol: NotRequired[pulumi.Input[str]]
        """
        Type of TCP check. Either SMTP, SSH or TCP
        """
        timeout: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait to receive the first byte
        """
elif False:
    UptimeCheckTcpCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckTcpCheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 authentication: Optional[pulumi.Input['UptimeCheckTcpCheckAuthenticationArgs']] = None,
                 protocol: Optional[pulumi.Input[str]] = None,
                 timeout: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] port: Destination port for TCP checks
        :param pulumi.Input['UptimeCheckTcpCheckAuthenticationArgs'] authentication: Authentication configuration block
        :param pulumi.Input[str] protocol: Type of TCP check. Either SMTP, SSH or TCP
        :param pulumi.Input[int] timeout: The number of seconds to wait to receive the first byte
        """
        pulumi.set(__self__, "port", port)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if timeout is not None:
            pulumi.set(__self__, "timeout", timeout)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        Destination port for TCP checks
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['UptimeCheckTcpCheckAuthenticationArgs']]:
        """
        Authentication configuration block
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['UptimeCheckTcpCheckAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[str]]:
        """
        Type of TCP check. Either SMTP, SSH or TCP
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter
    def timeout(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait to receive the first byte
        """
        return pulumi.get(self, "timeout")

    @timeout.setter
    def timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout", value)


if not MYPY:
    class UptimeCheckTcpCheckAuthenticationArgsDict(TypedDict):
        password: pulumi.Input[str]
        username: pulumi.Input[str]
elif False:
    UptimeCheckTcpCheckAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeCheckTcpCheckAuthenticationArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


